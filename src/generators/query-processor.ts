import { ReaderSpec, Filter, SortOption } from '../types';

export interface GeneratedQueryProcessor {
  filename: string;
  content: string;
}

export function generateQueryProcessor(
  spec: ReaderSpec
): GeneratedQueryProcessor {
  const resourceName = spec.resource.toLowerCase();
  const filename = `${resourceName}.query-processor.ts`;

  // Convert resource name to PascalCase for class names
  const pascalCaseName = spec.resource.replace(/_([a-z])/g, (_, letter) =>
    letter.toUpperCase()
  );

  const filterLogic = generateFilterLogic(spec.filters);
  const sortLogic = generateSortLogic(spec.sort);
  const paginationLogic = generatePaginationLogic(spec.paginate);

  const content = `// AUTO-GENERATED by ReaderSpec - Do not edit manually
import { ${pascalCaseName}ListQuery } from '../validation/${resourceName}.validation';

export interface QueryProcessorOptions {
  query: ${pascalCaseName}ListQuery;
  userId?: string;
}

export class ${pascalCaseName}QueryProcessor {
  private data: any[];

  constructor(data: any[]) {
    this.data = data;
  }

  process(options: QueryProcessorOptions): { items: any[]; total: number; page: number; per: number } {
    let filteredData = [...this.data];

    // Apply ownership filtering
    ${
      spec.ownership
        ? `
    if (options.userId) {
      // Find the actual field name that matches the ownership field
      const ownershipField = Object.keys(filteredData[0] || {}).find(key => 
        key.toLowerCase().includes('${spec.ownership.by.toLowerCase()}') || 
        key === '${spec.ownership.by}'
      );
      if (ownershipField) {
        filteredData = filteredData.filter(item => item[ownershipField] === options.userId);
      }
    }`
        : ''
    }

    // Apply filters
    filteredData = this.applyFilters(filteredData, options.query);

    // Get total count before pagination
    const total = filteredData.length;

    // Apply sorting
    filteredData = this.applySorting(filteredData, options.query);

    // Apply pagination
    const { items, page, per } = this.applyPagination(filteredData, options.query);

    return { items, total, page, per };
  }

  private applyFilters(data: any[], query: ${pascalCaseName}ListQuery): any[] {
    let filtered = data;

${filterLogic}

    return filtered;
  }

  private applySorting(data: any[], query: ${pascalCaseName}ListQuery): any[] {
    if (!query.sort_by) {
      return data;
    }

    const sortField = query.sort_by;
    const sortDirection = query.sort_dir || 'asc';

    return [...data].sort((a, b) => {
      const aVal = a[sortField];
      const bVal = b[sortField];

      if (aVal === bVal) return 0;

      const comparison = aVal < bVal ? -1 : 1;
      return sortDirection === 'desc' ? -comparison : comparison;
    });
  }

  private applyPagination(data: any[], query: ${pascalCaseName}ListQuery): { items: any[]; page: number; per: number } {
    const page = query.page || ${spec.paginate.startPage};
    const per = Math.min(query.per || ${spec.paginate.defaultPer}, ${spec.paginate.maxPer});
    
    const offset = (page - 1) * per;
    const items = data.slice(offset, offset + per);

    return { items, page, per };
  }
}
`;

  return { filename, content };
}

function generateFilterLogic(filters: Filter[]): string {
  if (filters.length === 0) {
    return '    // No filters defined';
  }

  return filters
    .map((filter) => {
      switch (filter.op) {
        case 'equals':
          return `    if (query.${filter.field}) {
      filtered = filtered.filter(item => item.${filter.field} === query.${filter.field});
    }`;
        case 'search':
          return `    if (query.${filter.field}) {
      const searchTerm = query.${filter.field}.toLowerCase();
      filtered = filtered.filter(item => 
        item.${filter.target || filter.field}.toLowerCase().includes(searchTerm)
      );
    }`;
        case 'in':
          return `    if (query.${filter.field} && Array.isArray(query.${filter.field})) {
      filtered = filtered.filter(item => query.${filter.field}!.includes(item.${filter.field}));
    }`;
        case 'range':
          return `    if (query.${filter.field}_min !== undefined) {
      filtered = filtered.filter(item => item.${filter.field} >= query.${filter.field}_min);
    }
    if (query.${filter.field}_max !== undefined) {
      filtered = filtered.filter(item => item.${filter.field} <= query.${filter.field}_max);
    }`;
        default:
          return `    // Filter ${filter.field} with operation ${filter.op} not implemented`;
      }
    })
    .join('\n\n');
}

function generateSortLogic(sortOptions: SortOption[]): string {
  if (sortOptions.length === 0) {
    return '    // No sort options defined';
  }

  return '    // Sorting logic implemented above';
}

function generatePaginationLogic(paginate: any): string {
  return '    // Pagination logic implemented above';
}

export function generateAllQueryProcessors(
  specs: ReaderSpec[]
): GeneratedQueryProcessor[] {
  return specs.map(generateQueryProcessor);
}
