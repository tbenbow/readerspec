import { ReaderSpec, Filter, SortOption } from '../types';

export interface GeneratedValidationSchema {
  filename: string;
  content: string;
}

export function generateValidationSchema(
  spec: ReaderSpec
): GeneratedValidationSchema {
  const resourceName = spec.resource.toLowerCase();
  const filename = `${resourceName}.validation.ts`;

  // Convert resource name to PascalCase for function names
  const pascalCaseName = spec.resource.replace(/_([a-z])/g, (_, letter) =>
    letter.toUpperCase()
  );

  const filterSchemas = generateFilterSchemas(spec.filters);
  const sortSchema = generateSortSchema(spec.sort);
  const paginationSchema = generatePaginationSchema(spec.paginate);

  const content = `// AUTO-GENERATED by ReaderSpec - Do not edit manually
import { z } from 'zod';

// Filter schemas
${filterSchemas}

// Sort schema
${sortSchema}

// Pagination schema
${paginationSchema}

// Main query schema
export const ${pascalCaseName}ListQuerySchema = z.object({
  // Filters
  ...filterSchemas,
  
  // Sorting
  ...sortSchemas,
  
  // Pagination
  ...paginationSchemas,
});

export type ${pascalCaseName}ListQuery = z.infer<typeof ${pascalCaseName}ListQuerySchema>;

// Helper function to validate and parse query parameters
export function validate${pascalCaseName}Query(query: Record<string, any>): ${pascalCaseName}ListQuery {
  return ${pascalCaseName}ListQuerySchema.parse(query);
}
`;

  return { filename, content };
}

function generateFilterSchemas(filters: Filter[]): string {
  if (filters.length === 0) {
    return '// No filters defined';
  }

  const filterSchemas = filters
    .map((filter) => {
      switch (filter.op) {
        case 'equals':
          return `  ${filter.field}: z.enum([${filter.values?.map((v) => `'${v}'`).join(', ')}]).optional(),`;
        case 'search':
          return `  ${filter.field}: z.string().optional(),`;
        case 'in':
          return `  ${filter.field}: z.string().array().optional(),`;
        case 'range':
          return `  ${filter.field}_min: z.number().optional(),
  ${filter.field}_max: z.number().optional(),`;
        default:
          return `  ${filter.field}: z.any().optional(),`;
      }
    })
    .join('\n');

  return `const filterSchemas = {
${filterSchemas}
};`;
}

function generateSortSchema(sortOptions: SortOption[]): string {
  if (sortOptions.length === 0) {
    return '// No sort options defined';
  }

  const sortFields = sortOptions
    .map((option) => `'${option.field}'`)
    .join(', ');
  const sortDirections = sortOptions
    .flatMap((option) => option.dir)
    .map((dir) => `'${dir}'`)
    .join(', ');

  return `const sortSchemas = {
  sort_by: z.enum([${sortFields}]).optional(),
  sort_dir: z.enum([${sortDirections}]).optional(),
};`;
}

function generatePaginationSchema(paginate: any): string {
  return `const paginationSchemas = {
  page: z.coerce.number().int().min(1).default(${paginate.startPage}).optional(),
  per: z.coerce.number().int().min(1).max(${paginate.maxPer}).default(${paginate.defaultPer}).optional(),
};`;
}

export function generateAllValidationSchemas(
  specs: ReaderSpec[]
): GeneratedValidationSchema[] {
  return specs.map(generateValidationSchema);
}
