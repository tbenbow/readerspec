import { ReaderSpec, Field, Filter, SortOption } from '../types';

export interface GeneratedOpenAPI {
  filename: string;
  content: string;
}

export function generateOpenAPI(specs: ReaderSpec[]): GeneratedOpenAPI {
  const content = generateOpenAPIContent(specs);
  return { filename: 'openapi.yaml', content };
}

function generateOpenAPIContent(specs: ReaderSpec[]): string {
  const paths = specs.map(generatePath).join('\n');
  const schemas = specs.map(generateSchema).join('\n');
  const components = generateComponents(specs);

  return `# Auto-generated by ReaderSpec - Simple, Human-Friendly API Documentation
openapi: 3.0.3
info:
  title: ReaderSpec Generated API
  description: |
    A simple, human-friendly API generated from ReaderSpec markdown files.
    
    ## What is this?
    This API was automatically generated from human-readable specifications.
    Each endpoint is designed to be simple and intuitive to use.
    
    ## How to use
    - **List items**: GET /{resource} - Get a list of items with filtering and pagination
    - **Filter**: Use query parameters to narrow down results
    - **Sort**: Choose how to order your results
    - **Paginate**: Control how many items you get back
    
    ## Authentication
    Set the \`x-user-id\` header to filter results to items you own.
  version: 1.0.0
  contact:
    name: ReaderSpec
    url: https://github.com/your-org/readerspec

servers:
  - url: http://localhost:3000
    description: Development server
  - url: https://api.yourdomain.com
    description: Production server

paths:
${paths}

components:
  schemas:
${schemas}
  
  parameters:
${components.parameters}
    
  responses:
${components.responses}
`;
}

function generatePath(spec: ReaderSpec): string {
  const resourceName = spec.resource.toLowerCase();
  const pascalCaseName = spec.resource.replace(/_([a-z])/g, (_, letter) =>
    letter.toUpperCase()
  );

  const parameters = generateQueryParameters(spec);
  const responses = generateResponses(spec);

  return `  /${resourceName}:
    get:
      summary: List ${spec.resource} items
      description: |
        Get a list of ${spec.resource.toLowerCase()} items with filtering, sorting, and pagination.
        
        ## What you can do:
        - **Filter** by various criteria (see parameters below)
        - **Search** through text content
        - **Sort** by different fields
        - **Paginate** through large result sets
        
        ## Ownership
        ${spec.ownership ? `Results are automatically filtered to show only items owned by the user specified in the \`x-user-id\` header.` : 'No ownership filtering applied.'}
      
      tags:
        - ${pascalCaseName}
      
      parameters:
${parameters}
      
      responses:
${responses}`;
}

function generateQueryParameters(spec: ReaderSpec): string {
  const params: string[] = [];

  // Add filter parameters
  spec.filters.forEach((filter) => {
    const param = generateFilterParameter(filter, spec);
    if (param) params.push(param);
  });

  // Add search parameter if exists
  const searchFilter = spec.filters.find((f) => f.op === 'search');
  if (searchFilter) {
    params.push(`        - name: q
          in: query
          description: Search term to find in ${searchFilter.target || 'text content'}
          required: false
          schema:
            type: string
          example: "example search term"`);
  }

  // Add sort parameters
  if (spec.sort.length > 0) {
    const sortFields = spec.sort.map((s) => s.field).join(', ');
    params.push(`        - name: sort_by
          in: query
          description: Field to sort by (${sortFields})
          required: false
          schema:
            type: string
            enum: [${sortFields}]
          example: "${spec.sort[0].field}"`);

    params.push(`        - name: sort_dir
          in: query
          description: Sort direction
          required: false
          schema:
            type: string
            enum: [asc, desc]
          example: "desc"`);
  }

  // Add pagination parameters
  params.push(`        - name: page
          in: query
          description: Page number (starts at ${spec.paginate.startPage})
          required: false
          schema:
            type: integer
            minimum: ${spec.paginate.startPage}
            default: ${spec.paginate.startPage}
          example: ${spec.paginate.startPage}`);

  params.push(`        - name: per
          in: query
          description: Items per page (max ${spec.paginate.maxPer})
          required: false
          schema:
            type: integer
            minimum: 1
            maximum: ${spec.paginate.maxPer}
            default: ${spec.paginate.defaultPer}
          example: ${spec.paginate.defaultPer}`);

  return params.join('\n');
}

function generateFilterParameter(
  filter: Filter,
  spec: ReaderSpec
): string | null {
  if (filter.op === 'search') return null; // Handled separately

  const field = spec.fields.find((f) => f.name === filter.field);
  if (!field) return null;

  let schema: string;
  let example: string;

  switch (filter.op) {
    case 'equals':
      if (filter.values && filter.values.length > 0) {
        schema = `            type: string
            enum: [${filter.values.map((v) => `"${v}"`).join(', ')}]`;
        example = filter.values[0];
      } else {
        schema = `            type: string`;
        example = 'example value';
      }
      break;
    case 'in':
      schema = `            type: array
            items:
              type: string`;
      example = 'value1,value2';
      break;
    case 'range':
      schema = `            type: number`;
      example = '100';
      break;
    default:
      schema = `            type: string`;
      example = 'example value';
  }

  return `        - name: ${filter.field}
          in: query
          description: Filter by ${filter.field}
          required: false
          schema:
${schema}
          example: "${example}"`;
}

function generateResponses(spec: ReaderSpec): string {
  const pascalCaseName = spec.resource.replace(/_([a-z])/g, (_, letter) =>
    letter.toUpperCase()
  );

  return `        200:
        description: Successfully retrieved ${spec.resource.toLowerCase()} items
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/${pascalCaseName}ListResponse'
            example:
              items:
                - ${generateExampleItem(spec)}
              page: 1
              per: ${spec.paginate.defaultPer}
              total: 1
        400:
          description: Bad request - invalid query parameters
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ErrorResponse'
              example:
                error: "Bad Request"
                message: "Invalid query parameters"
                details: "Validation failed"
        500:
          description: Internal server error
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ErrorResponse'
              example:
                error: "Internal Server Error"
                message: "Something went wrong"`;
}

function generateExampleItem(spec: ReaderSpec): string {
  const exampleFields = spec.fields
    .map((field) => {
      const value = generateExampleValue(field);
      return `${field.name}: ${value}`;
    })
    .join(', ');

  return `{ ${exampleFields} }`;
}

function generateExampleValue(field: Field): string {
  switch (field.type) {
    case 'id':
      return '"example-id"';
    case 'string':
      if (field.name.toLowerCase().includes('title')) return '"Example Title"';
      if (field.name.toLowerCase().includes('name')) return '"Example Name"';
      if (field.name.toLowerCase().includes('status')) return '"published"';
      if (field.name.toLowerCase().includes('category')) return '"Technology"';
      if (field.name.toLowerCase().includes('tags')) return '["tag1", "tag2"]';
      if (field.name.toLowerCase().includes('date'))
        return '"2024-01-01T00:00:00.000Z"';
      return '"Example Value"';
    case 'boolean':
      return '"yes"';
    case 'datetime':
      return '"2024-01-01T00:00:00.000Z"';
    case 'number':
      return '42';
    default:
      return 'null';
  }
}

function generateSchema(spec: ReaderSpec): string {
  const resourceName = spec.resource.toLowerCase();
  const pascalCaseName = spec.resource.replace(/_([a-z])/g, (_, letter) =>
    letter.toUpperCase()
  );

  const properties = spec.fields
    .map((field) => {
      const schema = generateFieldSchema(field);
      return `        ${field.name}:
          description: ${field.desc || `${field.name} field`}
${schema}`;
    })
    .join('\n');

  return `    ${pascalCaseName}:
      type: object
      description: A ${spec.resource.toLowerCase()} item
      properties:
${properties}
      required:
        - ${
          spec.fields
            .filter(
              (f) => f.name === 'id' || f.name.toLowerCase().includes('id')
            )
            .map((f) => f.name)
            .join('\n        - ') || 'id'
        }
      example:
        ${generateExampleItem(spec)}
    
    ${pascalCaseName}ListResponse:
      type: object
      description: Response containing a list of ${spec.resource.toLowerCase()} items
      properties:
        items:
          type: array
          description: List of ${spec.resource.toLowerCase()} items
          items:
            $ref: '#/components/schemas/${pascalCaseName}'
        page:
          type: integer
          description: Current page number
          example: 1
        per:
          type: integer
          description: Items per page
          example: ${spec.paginate.defaultPer}
        total:
          type: integer
          description: Total number of items matching the query
          example: 100`;
}

function generateFieldSchema(field: Field): string {
  switch (field.type) {
    case 'id':
      return `          type: string
          format: uuid`;
    case 'string':
      return `          type: string`;
    case 'boolean':
      return `          type: string
          enum: ["yes", "no"]`;
    case 'datetime':
      return `          type: string
          format: date-time`;
    case 'number':
      return `          type: number`;
    case 'array':
      return `          type: array
          items:
            type: string`;
    default:
      return `          type: string`;
  }
}

function generateComponents(specs: ReaderSpec[]): {
  parameters: string;
  responses: string;
} {
  const parameters = `    # Common query parameters
    userId:
      name: x-user-id
      in: header
      description: User ID for ownership filtering
      required: false
      schema:
        type: string
      example: "user-123"`;

  const responses = `    ErrorResponse:
      type: object
      description: Standard error response
      properties:
        error:
          type: string
          description: Error type
          example: "Bad Request"
        message:
          type: string
          description: Human-readable error message
          example: "Invalid query parameters"
        details:
          type: string
          description: Additional error details
          example: "Validation failed"`;

  return { parameters, responses };
}

export function generateAllOpenAPI(specs: ReaderSpec[]): GeneratedOpenAPI[] {
  return [generateOpenAPI(specs)];
}
