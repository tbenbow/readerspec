import { ReaderSpec, Field } from '../types';

export interface GeneratedTypeScriptTypes {
  filename: string;
  content: string;
}

export function generateTypeScriptTypes(
  specs: ReaderSpec[]
): GeneratedTypeScriptTypes {
  const content = generateTypesContent(specs);
  return { filename: 'types.ts', content };
}

function generateTypesContent(specs: ReaderSpec[]): string {
  const resourceTypes = specs.map(generateResourceTypes).join('\n\n');
  const commonTypes = generateCommonTypes();
  const apiClient = generateAPIClient(specs);

  return `// Auto-generated by ReaderSpec - Simple TypeScript types for your API
// These types make it easy to work with the generated API from your frontend

${resourceTypes}

${commonTypes}

${apiClient}

// ðŸŽ¯ Usage Examples:
// 
// // 1. Basic API calls
// const todos = await api.todo.list({ page: 1, per: 10 });
// 
// // 2. With filtering
// const publishedPosts = await api.blog_posts.list({ 
//   publication_status: 'published',
//   sort_by: 'creation_date',
//   sort_dir: 'desc'
// });
// 
// // 3. With search
// const searchResults = await api.blog_posts.list({ q: 'technology' });
// 
// // 4. With ownership (user-specific data)
// const myTodos = await api.todo.list({}, { userId: 'user-123' });
// 
// // 5. Type-safe responses
// const response: TodoListResponse = await api.todo.list();
// console.log(response.items[0].text); // TypeScript knows this is a string
`;
}

function generateResourceTypes(spec: ReaderSpec): string {
  const resourceName = spec.resource.toLowerCase();
  const pascalCaseName = spec.resource.replace(/_([a-z])/g, (_, letter) =>
    letter.toUpperCase()
  );

  const fieldTypes = spec.fields
    .map((field) => {
      const type = generateFieldType(field);
      const comment = field.desc ? ` // ${field.desc}` : '';
      return `  ${field.name}: ${type};${comment}`;
    })
    .join('\n');

  const filterTypes = generateFilterTypes(spec);
  const sortTypes = generateSortTypes(spec);
  const paginationTypes = generatePaginationTypes(spec);

  return `// ${spec.resource} Types
export interface ${pascalCaseName} {
${fieldTypes}
}

export interface ${pascalCaseName}ListQuery {
${filterTypes}
${sortTypes}
${paginationTypes}
}

export interface ${pascalCaseName}ListResponse {
  items: ${pascalCaseName}[];
  page: number;
  per: number;
  total: number;
}

// ${spec.resource} API methods
export interface ${pascalCaseName}API {
  list(query?: ${pascalCaseName}ListQuery, options?: APIOptions): Promise<${pascalCaseName}ListResponse>;
}`;
}

function generateFieldType(field: Field): string {
  switch (field.type) {
    case 'id':
      return 'string';
    case 'string':
      return 'string';
    case 'boolean':
      return '"yes" | "no"';
    case 'datetime':
      return 'string'; // ISO date string
    case 'number':
      return 'number';
    case 'array':
      return 'string[]';
    default:
      return 'any';
  }
}

function generateFilterTypes(spec: ReaderSpec): string {
  const filters: string[] = [];

  spec.filters.forEach((filter) => {
    if (filter.op === 'search') return; // Handled separately

    let type: string;
    switch (filter.op) {
      case 'equals':
        if (filter.values && filter.values.length > 0) {
          type = filter.values.map((v) => `"${v}"`).join(' | ');
        } else {
          type = 'string';
        }
        break;
      case 'in':
        type = 'string[]';
        break;
      case 'range':
        type = 'number';
        break;
      default:
        type = 'string';
    }

    filters.push(`  ${filter.field}?: ${type};`);
  });

  // Add search parameter if exists
  const searchFilter = spec.filters.find((f) => f.op === 'search');
  if (searchFilter) {
    filters.push(
      `  q?: string; // Search term for ${searchFilter.target || 'text content'}`
    );
  }

  return filters.join('\n');
}

function generateSortTypes(spec: ReaderSpec): string {
  if (spec.sort.length === 0) return '';

  const sortFields = spec.sort.map((s) => `"${s.field}"`).join(' | ');
  const sortDirections = spec.sort
    .flatMap((s) => s.dir)
    .map((d) => `"${d}"`)
    .join(' | ');

  return `  sort_by?: ${sortFields};
  sort_dir?: ${sortDirections};`;
}

function generatePaginationTypes(spec: ReaderSpec): string {
  return `  page?: number; // Page number, starts at ${spec.paginate.startPage}
  per?: number; // Items per page, max ${spec.paginate.maxPer}`;
}

function generateCommonTypes(): string {
  return `// Common API Types
export interface APIOptions {
  userId?: string; // For ownership filtering
  baseURL?: string; // API base URL
}

export interface APIError {
  error: string;
  message: string;
  details?: string;
}

// Generic API response wrapper
export interface APIResponse<T> {
  data: T;
  error?: never;
}

export interface APIErrorResponse {
  data?: never;
  error: APIError;
}

export type APIResult<T> = APIResponse<T> | APIErrorResponse;

// Helper type for checking if response is successful
export function isSuccess<T>(response: APIResult<T>): response is APIResponse<T> {
  return 'data' in response;
}

export function isError<T>(response: APIResult<T>): response is APIErrorResponse {
  return 'error' in response;
}`;
}

function generateAPIClient(specs: ReaderSpec[]): string {
  const resourceAPIs = specs
    .map((spec) => {
      const resourceName = spec.resource.toLowerCase();
      const pascalCaseName = spec.resource.replace(/_([a-z])/g, (_, letter) =>
        letter.toUpperCase()
      );

      return `  ${resourceName}: ${pascalCaseName}API;`;
    })
    .join('\n');

  const resourceImplementations = specs
    .map((spec) => {
      const resourceName = spec.resource.toLowerCase();
      const pascalCaseName = spec.resource.replace(/_([a-z])/g, (_, letter) =>
        letter.toUpperCase()
      );

      return `    ${resourceName}: {
      async list(query: ${pascalCaseName}ListQuery = {}, options: APIOptions = {}): Promise<${pascalCaseName}ListResponse> {
        const params = new URLSearchParams();
        
        // Add query parameters
        Object.entries(query).forEach(([key, value]) => {
          if (value !== undefined && value !== null) {
            if (Array.isArray(value)) {
              params.append(key, value.join(','));
            } else {
              params.append(key, String(value));
            }
          }
        });
        
        const url = \`\${baseURL}/${resourceName}\${params.toString() ? '?' + params.toString() : ''}\`;
        const headers: Record<string, string> = {};
        
        if (options.userId) {
          headers['x-user-id'] = options.userId;
        }
        
        const response = await fetch(url, { headers });
        
        if (!response.ok) {
          const error = await response.json();
          throw new Error(error.message || \`HTTP \${response.status}\`);
        }
        
        return await response.json();
      }
    }`;
    })
    .join(',\n');

  return `// API Client
export class APIClient {
  private baseURL: string;

  constructor(baseURL: string = 'http://localhost:3000') {
    this.baseURL = baseURL;
  }

  // Resource APIs
${resourceAPIs}
}

// Create a default API client instance
export const api = new APIClient();

// Individual resource clients for convenience
${specs
  .map((spec) => {
    const resourceName = spec.resource.toLowerCase();
    const pascalCaseName = spec.resource.replace(/_([a-z])/g, (_, letter) =>
      letter.toUpperCase()
    );
    return `export const ${resourceName}API: ${pascalCaseName}API = api.${resourceName};`;
  })
  .join('\n')}

// Implementation
const baseURL = 'http://localhost:3000';

const apiClient = {
${resourceImplementations}
};

// Export the implementation
export { apiClient };`;
}

export function generateAllTypeScriptTypes(
  specs: ReaderSpec[]
): GeneratedTypeScriptTypes[] {
  return [generateTypeScriptTypes(specs)];
}
